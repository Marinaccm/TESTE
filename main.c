//IMPORTANTE
//Para este visto, o joy deve ser ligado em uma protoboard, o que fará com que URY leia direita e esquerda e URX leia cima e baixo

//LIGAÇÕES
///Motor A IA-----P6.0(MSP)
///Motor A IB-----P6.1(MSP)
///GND ponte H----- pilha
///VCC ponte H-----pilha

///P3.0 (MSP)----- SDA(LCD)
///P3.1 (MSP)----- SCL(LCD)
///GND(LCD)-----GND(MSP)
///VCC(LCD)-----5V(MSP)


//INCLUIR BIBLIOTECAS
#include <msp430.h>
//CONFIGURAR VARIAVEIS AUXILIARES

//////Controle do LCD
#define BIT_RS   BIT0
#define BIT_RW   BIT1
#define BIT_E    BIT2
#define BIT_BL   BIT3
#define BIT_D4   BIT4
#define BIT_D5   BIT5
#define BIT_D6   BIT6
#define BIT_D7   BIT7

//////Taxas de transmisão
#define BR100K      10                          //100 kbps
#define BR50K       20                          // 50 kbps
#define BR10K       100                         // 10 kbps
#define TRIGGER_PIN     BIT2   // P1.2
#define R_ECHO      BIT3    //P1.3, pull-up resistor
#define f_pwm  200 //Defines the frequency of the pwm wave generated by A1
#define duty_pwm 100//defines the duty-cycle of the pwm wave

// Notas
#define c 261       //DÓ
#define d 294       //Ré
#define e 329       //Mi
#define f 349       //Fá
#define g 391       //Sol
#define gS 415
#define a 440
#define aS 455
#define b 466
#define cH 523
#define cSH 554
#define dH 587
#define dSH 622
#define eH 659
#define fH 698
#define fSH 740
#define gH 784
#define gSH 830
#define aH 880

volatile unsigned int distance = 0;
volatile unsigned int lastCount = 0;
volatile unsigned int risingEdge = 0;
volatile unsigned int fallingEdge = 0;
volatile unsigned int pulseWidth = 0;

int Cont;

const unsigned long UP[8]={0b00011000, 0b01110, 0b10101, 0b00100, 0b00100, 0b00100, 0b00000, 0b00000};//DEFINE MAP
const unsigned long DOWN[8]={0x00,0x00,0x04,0x04,0x04,0x15,0x0E,0x04};//DEFINE MAP

//LISTAGEM DE FUNÇÕES
//////Para melhor construção, debug e funcionamento do código, decidimos dividir o código em subrotinas, cada uma com uma função associada

void wait_receive(long tempo);   //Cria timer em A0 para contagem de tempo apos escrita
void PCF_write(char dado);          // Escreve variável "dado" na porta
int PCF_read(void);                 //Lê a porta do PCF
void LCD_00(void);                  // Zera o LCD
void lcdBacklightON(void);          // Liga o Back Light
void lcdBacklightOFF(void);         // Desliga o Back Light
void LCD_rs_rw(void);               //Porta envia comando para controlador do display e indica dados de leitura
void LCD_rs_RW(void);               //Porta envia comando para controlador do display e lê registros do controlador
void LCD_RS_rw(void);               //Porta envia dado para controlador do display e indica dados de escrita
void LCD_RS_RW(void);               //Porta envia comando para controlador do display e lê registros do controlador
void LCD_OFF(void);                 //Desliga BITS do LCD
void LCD_ON(void);                  //Liga BITS do LCD
void LCD_WR_NIB(char valor);
void LCD_WR_BT(char escrita);
void LCD_start(void);               //Liga LCD/condições iniciais
void LCD_posicao(char posicao);     //Funcao que cria sistema de coordenadas do LCD, sem precisar se preocupar com o cursor
void sendString(char*);             //Crada para permitir escrever strings de caracteres mais facilmente
void LCD_char1(char letra);         //Criada para faciliar escrita de caracteres no LCD, as demais funções que terminam com "1" aqui citadas servem para auxiliar esta função principal
void LCD_rs_rw1(void);              //escrever
void LCD_RS_rw1(void);              //escrever
void LCD_rs_RW1(void);              //ler
void LCD_RS_RW1(void);              //ler
void LCD_wr_nib1(char nib);         //nibble
void LCD_wr_byte1(char byte);
void LCD_clr1(void);
void itoa(int i, char buffer[]);    // transforma de inteiro para vetor de char
void BUZZ_inic(void);
void turnRight(int dir);            // Vira para direita caso dir = 0 ou para esquerda caso dir = 1

// define the up-arrow bitmap

int valor_porta = 0;                //Úlitmo valor escrito na porta
char distance_string[5];

void main(void)
{
    WDTCTL = WDTPW | WDTHOLD;                   //Stop watchdog timer



    // CONFIGURA PINOS I2C - UCSB0
    ////// P3.0 --> SDA
    P3SEL |=  BIT0;             //Seta pino P3.0 como periférico
    P3REN |=  BIT0;             // Habilita resistor
    P3OUT |=  BIT0;             // Resistor do tipo Pull-up

    ////// P3.1 --> SCL
    P3SEL |=  BIT1;             //Seta pino P3.1 como periférico
    P3REN |=  BIT1;             // Habilita resistor
    P3OUT |=  BIT1;             // Resistor do tipo Pull-up

    //////Motor 1 IA
    P6SEL |=  BIT0;             //Seta pino P6.0 como periférico
    P6REN |=  BIT0;             // Habilita resistor
    P6OUT |=  BIT0;             // Pull-up

    //////Motor 1 IB
    P6SEL |=  BIT1;             //Seta pino P6.1 como periférico
    P6REN |=  BIT1;             // Habilita resistor
    P6OUT |=  BIT1;             // Resistor do tipo Pull-up

    //////Motor 2 IA
    P6SEL |=  BIT1;             //Seta pino P6.0 como periférico
    P6REN |=  BIT1;             // Habilita resistor
    P6OUT |=  BIT1;             // Pull-up

    //////Motor 2 IB
    P6SEL |=  BIT2;             //Seta pino P6.1 como periférico
    P6REN |=  BIT2;             // Habilita resistor
    P6OUT |=  BIT2;             // Resistor do tipo Pull-up


    UCB0CTL1 |= UCSWRST;        // UCSI B0 em ressete

    UCB0CTL0 = UCSYNC |         //Síncrono
            UCMODE_3 |          //Modo I2C
            UCMST;              //Mestre

    UCB0BRW = 20;               // 50 kbps

    UCB0CTL1 = UCSSEL_2;        //SMCLK e remove ressete


    LCD_start();
    LCD_00();
    LCD_posicao(0x00);
    lcdBacklightON();
    LCD_RS_rw();

    while(1){
        if ((P2IN & BIT1)==0){
            __delay_cycles(1000000);
            if ((P2IN & BIT1)==0){
                __delay_cycles(1000000);
                if ((P2IN & BIT1)==0){
                    LCD_posicao(0x01);
                    sendString("CLEANING TIME!");
                    LCD_posicao(0x40);
                    sendString("Distance:");
                    LCD_posicao(0x4E);
                    sendString("cm");
                    BUZZ_inic();
                    t1_inic();
                    t2_inic();
                }
            }
        }
    }

}



void wait_receive(long tempo)
{
    // Cria um Timer em A0
    //////Com clock SMCLK (~=1MHz)|Sem dividir clock|UP mode|Reseta contagem
    TA0CTL = TASSEL_2 | ID_0 | MC_1 | TACLR;
    //TA0CCR0 = tempo;                //tempo em us
    TA0CCTL0 &= ~TAIFG;             //Limpa IFG
    TA0CCR0 = 300;                  //Conta as batidas do clock
    TA0CCR1 = 150;                   //Duty-cycle
    TA0CCTL1 = OUTMOD_6;            //Saída em "Toggle/Set":toggles para CCRn e seta para CCR0

    while((TA0CCTL0 & TAIFG) == 0); //Espera TAIFG não ser Zero

}

void PCF_write(char dado)
{

    // Escreve variável "dado" na porta

    UCB0I2CSA = 0x27;                               //Endereço do Escravo

    UCB0CTL1 |= UCTR    |                           //Mestre transmissor
            UCTXSTT;                                //Gera START e envia endereço

    while ( (UCB0IFG & UCTXIFG) == 0);              //Espera fim da transmissão

    UCB0TXBUF = dado;                               //Define a variável "dado" como a transmitida no buffer
    //ou seja, "dado" a ser escrito

    while ( (UCB0IFG & UCTXIFG) == 0);              //Espera fim da transmissão

    UCB0CTL1 |= UCTXSTP;                            //Gera STOP

    while ( (UCB0CTL1 & UCTXSTP) == UCTXSTP );      //Espera STOP

    __delay_cycles(500);                                      //Atraso p/ escravo perceber stop

}

int PCF_read(void)
{
    //Lê a porta do PCF

    int dado = 0;                               //Comeca com dado zerado
    UCB0CTL1 &= ~UCTR;                          //Mestre RX
    UCB0CTL1 |= UCTXSTT;                        //Gera Start
    while((UCB0CTL1 & UCTXSTT) == UCTXSTT );    //Espera o Start
    UCB0CTL1 |= UCTXSTP;                        //Gera Stop + NACK
    while ( (UCB0IFG & UCRXIFG) == 0 );         //Espera RX
    dado = UCB0RXBUF;                           //Altera valor deaddo como valor do Buffer
    __delay_cycles(1000);                                 //Delay de 100ms
    return dado;                                //Retorna dado = UCB0RXBUF

}


void LCD_00(void)
{
    // Zera o LCD
    valor_porta = 0;
    PCF_write(valor_porta);
    LCD_RS_rw();

}


void lcdBacklightON(void)
{
    // Liga o Back Light
    valor_porta = valor_porta | BIT_BL;
    PCF_write(valor_porta);

}

void lcdBacklightOFF(void)
{

    // Desliga Back Light
    valor_porta = valor_porta & ~BIT_BL;
    PCF_write(valor_porta);

}

void LCD_rs_rw(void)
{
    ///RS -> Register Select: Indica se estamos enviando um
    //comando para o controlador do display (RS=0) ou um dado
    //a ser mostrado na tela (RS=1).

    //RW -> Read/Write: Indica se os dados expostos nos pinos
    //D0 a D7 são dados de escrita (RW=0) ou leitura de
    //registros do controlador do display (RS=1). A maioria
    //das aplicações preferem manter este dado em nível 0
    //(Aterrado) devido a necessidade de apenas escrita de
    //comandos e dados.

    //Porta envia comando para controlador do display e indica dados de leitura
    valor_porta = valor_porta & ~BIT_RS;
    valor_porta = valor_porta & ~BIT_RW;
    PCF_write(valor_porta);

}

void LCD_rs_RW(void)
{

    //Porta envia comando para controlador do display e lê registros do controlador
    valor_porta = valor_porta & ~BIT_RS;
    valor_porta = valor_porta | BIT_RW;
    PCF_write(valor_porta);

}

void LCD_RS_rw(void)
{

    //Porta envia dado para controlador do display e indica dados de escrita
    valor_porta = valor_porta | BIT_RS;
    valor_porta = valor_porta & ~BIT_RW;
    PCF_write(valor_porta);

}

void LCD_RS_RW(void)
{
    //Porta envia comando para controlador do display e lê registros do controlador
    valor_porta = valor_porta | BIT_RS;
    valor_porta = valor_porta | BIT_RW;
    PCF_write(valor_porta);

}

void LCD_OFF(void)
{
    //Desliga BITS do LCD
    valor_porta = valor_porta & ~BIT_E;
    PCF_write(valor_porta);

}

void LCD_ON(void)
{
    //Liga BITS do LCD
    valor_porta = valor_porta | BIT_E;
    PCF_write(valor_porta);

}

void LCD_WR_NIB(char valor)
{

    valor_porta &= 0xF;
    valor_porta |= (valor<<4);
    PCF_write(valor_porta);
    LCD_ON();
    __delay_cycles(100);
    LCD_OFF();
    __delay_cycles(100);

}

void LCD_WR_BT(char escrita)
{

    LCD_WR_NIB((escrita >> 4) & 0xF);
    LCD_WR_NIB(escrita & 0xF);

}

void LCD_start(void)
{

    LCD_rs_rw();

    __delay_cycles(200);

    LCD_WR_NIB(0x3);

    wait_receive(300);

    LCD_WR_NIB(0x3);

    __delay_cycles(100);

    LCD_WR_NIB(0x3);

    LCD_WR_NIB(0x2);

    LCD_WR_NIB(0x2);
    LCD_WR_NIB(0x8);

    LCD_WR_NIB(0x0);
    LCD_WR_NIB(0xC);

    LCD_WR_NIB(0x0);
    LCD_WR_NIB(0x1);

    LCD_WR_NIB(0x0);
    LCD_WR_NIB(0x6);

}

void LCD_posicao(char posicao)
{

    LCD_rs_rw();
    int aux = 0;
    aux = (posicao >> 4) & 0xF;
    aux |= BIT3;
    LCD_WR_NIB(aux);
    LCD_WR_NIB(posicao & 0xF);
    LCD_RS_rw();

}

void sendString(char* str){
    while(*str)
        LCD_WR_BT(*str++);
}

//void rotateLeftMotorRight(){
//    // Rotate Left Motor
//    P6OUT |=  BIT0;
//    P6OUT &= ~BIT1;
//
//    // Stop Right Motor
//    P6OUT &= ~BIT3;
//    P6OUT &= ~BIT4;
//}
//
//void rotateLeftMotorLeft(){
//    // Rotate Left Motor
//    P6OUT &= ~BIT0;
//    P6OUT |=  BIT1;
//
//    // Stop Right Motor
//    P6OUT &= ~BIT3;
//    P6OUT &= ~BIT4;
//}

void turnRight(int dir){
    if(dir == 0){
        // Rotate Left Motor
        P6OUT &= ~BIT0;
        P6OUT &= ~BIT1;

        // Stop Right Motor
        P6OUT &= ~BIT3;
        P6OUT |=  BIT4;
    }
    else if(dir == 1){
        // Rotate Left Motor
        P6OUT &= ~BIT0;
        P6OUT |=  BIT1;

        // Stop Right Motor
        P6OUT &= ~BIT3;
        P6OUT &= ~BIT4;
    }
}

void sendDistance(char* str, int len){
    while(len--)
        if (*str)
            LCD_WR_BT(*str++);
        else
            LCD_WR_BT(' ');
}

void LCD_rs_rw1(void) //escrever
{
    valor_porta &=~ BIT_RS;
    valor_porta &=~ BIT_RW;
    PCF_write(valor_porta);
}

void LCD_RS_rw1(void) //escrever
{
    valor_porta &= ~BIT_RW;
    valor_porta |= BIT_RS;
    PCF_write(valor_porta);
}

void LCD_rs_RW1(void) //ler
{
    valor_porta &=~BIT_RS;
    valor_porta |=BIT_RW;
    PCD_write(valor_porta);
}

void LCD_RS_RW1(void) //ler
{
    valor_porta |= BIT_RS;
    valor_porta |= BIT_RW;
    PCF_write(valor_porta);

}

void LCD_wr_nib1(char nib)
{
    valor_porta = (valor_porta & 0xF)|(nib <<4);
    PCF_write(valor_porta);
    valor_porta |= BIT_E;
    PCF_write(valor_porta);
    valor_porta &=~ BIT_E;
    PCF_write(valor_porta);
}

void LCD_wr_byte1(char byte)
{
    LCD_wr_nib1(byte>>4);
    LCD_wr_nib1(byte & 0xF);
}

void LCD_char1(char letra)
{
    LCD_RS_rw1();
    LCD_wr_byte1(letra);
}

void LCD_clr1(void)
{
    LCD_rs_rw1();
    LCD_wr_byte1(0x1);
}

void itoa(int i, char buffer[])
{
    buffer[0] = ' ';
    buffer[1] = ' ';
    buffer[2] = ' ';
    buffer[3] = ' ';
    buffer[4] = '\0';
    char const digit[] = "0123456789";
    char* p = buffer;
    if(i<0){
        *p++ = '-';
        i *= -1;
    }
    int shifter = i;
    do{ //Move to where representation ends
        ++p;
        shifter = shifter/10;
    }while(shifter);
    *p = ' ';
    do{ //Move back, inserting digits as u go
        *--p = digit[i%10];
        i = i/10;
    }while(i);
    __delay_cycles(100000);
    //    return buffer;
}

void BUZZ_inic(void){
    P2DIR |= BIT5;  //Saída PWM
    P2OUT &= ~BIT5;
    P2SEL |= BIT5;

    P2DIR |= BIT4;  //Não usado?
    P2OUT &= ~BIT4;
}

// Gerar tom com frequência = "freq"
// Durante período = tempo mili_seg
void nota(int freq, int tempo){
    volatile int cont=0,comp0,comp2;
    if (freq != 0){
        comp0=TA2CCR0 = 1048576L/freq;
        TA2CCR0 = comp0;                //Prog freq

        comp2 = TA2CCR0/2;
        TA2CCR2 = comp2;                //Carga 50%
        cont = freq*(tempo/1000.);      //Quantidade de períodos
    }
    else{
        P2SEL &= ~BIT5;                 //Desligar saída
        comp0=TA2CCR0 = 1048576L/1000;  //Programar 1 kHz
        comp2=TA2CCR2 = TA2CCR0/2;      //Carga  50%
        cont = tempo;                   //Quantidade de períodos
    }
    while(cont != 0){
        while( (TA2CCTL0&CCIFG) == 0);  //Usar CCIFG para
        TA2CCTL0 &= ~CCIFG;             //contar quantidade
        cont--;                         //de períodos
    }
    P2SEL |= BIT5;
}


void t1_inic(void){

    //TRIGGER

    // To configure the trigger it was chosen to use timer A0, capture and comparison
    //Initially configured to determine interruption upon detection of a up slope
    //Pin 1.2 is going to be associated with the trigger pin (output)
    P1DIR |= TRIGGER_PIN;   //Defined above as Pin 1.2
    P1OUT &= ~TRIGGER_PIN;  //Trigger is low to start
    //LEDs

    // To configure the LEDs we called
    P1DIR |= BIT0;  //RED LED, P1.0
    P1OUT &= ~BIT0; //RED LED STARTS OFF

    P4DIR |= BIT7;  //GREEN LED, P4.7
    P4OUT &= ~BIT7; //GREEN LED STARTS OFF

    //BOTÃO
    P2DIR &= ~BIT1; //Configures s1 as input
    P2REN |= BIT1;  //Relative to the resistor
    P2OUT |= BIT1;  //pull up
    //P2IE |= BIT1;   //local interruption
    //P2IES |= BIT1;  //edge select
    //P2IFG = 0;  //keeps interruption flags

    // To configure the BUZZER we called
    P3DIR |= BIT5;  //Buzzer, P1.4
    P3SEL &= ~BIT5;  //Relative to the resistor
    P3OUT |= BIT5; //Buzzer stars off

    //ECHO

    //Output for SR04 and input for distance processing
    //Pin 1.3 (Input/peripheral), we chose to use ccr2  to capture the time stamp
    P1SEL |= BIT3;  //Sets P1.3 as the peripheral
    P1DIR &= ~BIT3;  //(ECHO INPUT: CCI2A from TA0CCR2)
    //P1REN |= R_ECHO;    //Selects pull-up resistor function
    //P1OUT &= ~R_ECHO;   //Selects pull-down resistor function


    //TIMERS
    //
    // TIMER A0 WAS CHOSEN TO SEND THE TRIGGER AND RECIEVE THE ECHO SIGNALS
    //A0 is used in capture mode (CM_3) to gather the value at the up slope and the down slope,
    //Therefore, as a result we should have the pulse width of the echo
    //Setting up TA0 to capture in CCR2 on both edges
    TA0CCTL2 = CM_3 | CCIS_0 | SCS | CAP | CCIE;
    //Capture both edges/select the capture input (CCI2A, pin 1.3)/sync capture with timer/capture mode (0 would be comparison)/interrupt CCIFG                        TA0CCTL0 = CCIE;
    //TA0CCTL0 = CCIE;
    TA0CCTL1 = CCIE; //Not strictly essential, but values were being wrongly allocated before this line was added
    //CONTADOR DO TIMER A0
    TA0CTL = TASSEL_1|MC_1|TACLR|TAIE;
    //First we select the clock source as ACLK//then the timer is put in UP MODE//Reset the timer//TAIE calls off the flag TAIFG
    TA0CCR1 = 4;//Pulse width should be at least 10us, so y= 3,2768, used 4 to a trigger duration of 12,2us
    TA0CCR0 = 393;  //The problem asks for the maximum duration to be of 12ms, so X= 0,012/91/32768)= 393,216

    __enable_interrupt();

}


void t2_inic(void){
    TA2CTL = TASSEL_2|ID_0|MC_1|TACLR;
    TA2EX0 = TAIDEX_0;
    TA2CCTL2 = OUTMOD_6;
    TA2CCR0 = 2*1048;
    TA2CCR2 = TA2CCR0/2;
}

//INTERRUPTIONS

//interrupt service routine

#pragma vector = TIMER0_A0_VECTOR // Interrupt TA0CCR0
__interrupt void TA0_CCR0_ISR(void){
} // Close

#pragma vector = TIMER0_A1_VECTOR // Interrupt TA0 non-CCIFG0
__interrupt void TA0_ISR(void){
    switch(TA0IV) {
    case 0x2: // Interrupt TA0CCR1
        P1OUT &= ~BIT2; // Stop Trigger
        break;

    case 0x4: // Interrupt source TA0CCR2 (RISING AND FALLING EDGES)
        if (TA0CCTL2 & CCI) {
            // CCR2 interrupt (RISING edge)
            risingEdge = TA0CCR2;
        }// Store rising edge time value

        else {
            // CCR2 interrupt (FALLING edge)
            fallingEdge = TA0CCR2; // Store falling edge time value
            pulseWidth = (fallingEdge - risingEdge);
            distance = ((pulseWidth - lastCount)/2);
            //distance *= 17000; //speed of sound/2 considering the going and coming back
            //distance >>= 14;  // division by 16384 (2 ^ 14)
            if (pulseWidth <= 38)
            {
                // Turn on red LED
                P1OUT |= BIT0;
                P4OUT &= ~BIT7;
                LCD_posicao(0x49);
                sendString(" ");
                LCD_posicao(0x4B);
                //itoa(pulseWidth, distance_string, 10);
                itoa(distance, distance_string);
                sendDistance(distance_string, 3);
                P6OUT |= BIT0; // P1OUT |= BIT4;
                P6OUT &= ~BIT1; // P1OUT &= ~BIT5;
                //P1OUT |= BIT4;//liga buzzer
                __delay_cycles(10);
                nota(0,100);
            }

            if ((pulseWidth > 38) && (pulseWidth <=77) )
            {
                //Turn on green LED
                P1OUT &= ~BIT0;
                P4OUT |= BIT7;
                nota(0,100);
            }
            if (pulseWidth > 77)
            {
                // Turn on both
                P1OUT |= BIT0;
                P4OUT |= BIT7;
                LCD_posicao(0x49);
                sendString("> 200");
                nota(0,100);
            }

        } // Close if-else
        break;

    case 0xE: // Interrupt source TAIFG (CCR0)
        P1OUT |= BIT2; // Set P1.2 on (START TRIGGER)
        break;
    default: break;

    } //close switch
}

